lcomment C000          Input MD5   : 678F8F35B4A2F44926AB67C3B64C4BD4
comment C002 .The processor runs in MCU Mode 1.
comment C002 .Memory map:
comment C002 .R  - 0000-0027 - MCU I/O registers
comment C002 .0028-003F - Empty
comment C002 .RW - 0040-013F - On-board RAM
comment C002 .013F-7FFF - Empty
comment C002 .What does the processor do with external address lines below 0140?
comment C002 .What does the processor do with accesses to 0028-003F?
comment C002 .Any external addressing is mapped to 8000+ by the address decoding hardware.
comment C002 .RW - 8000-BFFF - Code plug EEPROM
comment C002 .R  - C000-FFFF - Firmware EPROM (might be writable with jumpers)
comment C002 .I/O map (write-only):
comment C002 .W  - 4000-4007 - Synthesizer registers (latch U503)
comment C002 .W  - C000-C000 - Audio control bus register (latch U504)
comment C002 .Audio control bus bit map:
comment C002 .D0 - RX through de-emphasis filter (inverted at switch)
comment C002 .D1 - RX flat                       (inverted)
comment C002 .D2 - TX through splatter filter    (inverted)
comment C002 .D3 - TX flat
comment C002 .D4 - Preamp /WE                    (inverted, because /WE)
comment C002 .D5 - Squelch LSB
comment C002 .D6 - Squelch MSB
comment C002 .D7 - Mic mute                      (inverted)
comment C002 .-
comment C002 .RAM usage
comment C002 .M0043 User number
comment C002 .M0049 Current squelch level 0-5
comment C002 .-
comment C002 .M0074 bits (set to 0xC3 on reset)
comment C002 . 0x20 HUB active (deactive ??)
comment C002 . 0x10 PL disabled (set/cleared by RXPLIN)
comment C002 .-
comment C002 .M0075 bits default value on cold start = 0x82
comment C002 . 0x80 ??
comment C002 . 0x10 ??
comment C002 . 0x08 ??
comment C002 . 0x04 ??
comment C002 . 0x02 PTT active   active low (set/cleared by SETBUT for PTT button)
comment C002 . 0x01 PTT enabled (set/cleared by PTTINH)
comment C002 .-
comment C002 .M0076 bits
comment C002 . 0x80 ??
comment C002 . 0x40 Front / rear control head (??
comment C002 . 0x20 PL disabled (set by RXPLIN)
comment C002 . 0x08 ??
comment C002 .-
comment C002 .M007B bits
comment C002 . 0x08 D1 from VOLVAL command
comment C002 . 0x04 D2 from VOLVAL command
comment C002 .-
comment C002 .M007C Current vol level
comment C002 .-
comment C002 .M0082 bits
comment C002 . 0x20 Audio muted
comment C002 . 0x04 Set when activating a new mode
comment C002 . 0x01 Scanning enabled in current mode
comment C002 .-
comment C002 .M0083 bits
comment C002 . 0x80 
comment C002 . 0x20 Even/odd main loop flag 
comment C002 . 0x10 Extender On ?
comment C002 .-
comment C002 .M0086 bits
comment C002 . 0x80 configuration mode active (set by ENTBUT, cleared by EXTBUT)
comment C002 . 0x40 ??
comment C002 . 0x01 alert tone on
comment C002 .-
comment C002 .M008D to M0090 form a 32 bit bitmapped vector, each bit corresponds to a 
comment C002 .  message to send when the SB9600 bus is not busy when polled.  Once the
comment C002 .  message is sent sucessfully the bit is cleared
comment C002 .-
comment C002 .M008D bits note: set from CP offset 0x14 initally (usually 0xC0)
comment C002 . 0x80 send RADRDY
comment C002 . 0x40 send ACTMDU
comment C002 . 0x20 send RXMODE
comment C002 . 0x10 send TXMODE
comment C002 . 0x08 send RADKEY
comment C002 . 0x04 send SQLDET
comment C002 . 0x02 send PLDECT
comment C002 . 0x01 send AUDMUT
comment C002 .-
comment C002 .M008E bits note: set from CP offset 0x15 initally (usually 0x20)
comment C002 . 0x80 send ACTSTU   
comment C002 . 0x40 send PTTINH
comment C002 . 0x20 send DISPLY mode XX (mode changed)
comment C002 . 0x10 send DISPLY  
comment C002 . 0x08 send DISPLY Field ID 2  
comment C002 . 0x04 send DISPLY Field ID 3 squelch level
comment C002 . 0x02 send DISPLY Field ID 9
comment C002 . 0x01 send DISPLY Field ID 10
comment C002 .-
comment C002 .M008F bits note: set from CP offset 0x16 initally (usually 0x00)
comment C002 . 0x80 send DISPLY Field ID 11
comment C002 . 0x40 send ??  
comment C002 . 0x20 send ??
comment C002 . 0x10 send ??  
comment C002 . 0x08 ??
comment C002 . 0x04 send ??
comment C002 . 0x02 send ??  
comment C002 . 0x01 ?? 
comment C002 .-
comment C002 .M0090 bits note: set from CP offset 0x17 initally (usually 0x00)
comment C002 . 0x80   
comment C002 . 0x40   
comment C002 . 0x20
comment C002 . 0x10   
comment C002 . 0x08   
comment C002 . 0x04   
comment C002 . 0x02   
comment C002 . 0x01   
comment C002 .-
comment C002 .M0093, M0094  set as a pair,  M0093 = LSB of adr of bitmap, M0094 bit to set 
comment C002 .-
comment C002 .M00AA Step # in current alert tone pattern
comment C002 .-
comment C002 .M00AC set to 0x08 or 0x03 when a new mode is activated, also set to 0x88
comment C002 . 0x80
comment C002 . 0x40   
comment C002 . 0x20   
comment C002 . 0x10   
comment C002 . 0x08   
comment C002 . 0x04   
comment C002 . 0x02   
comment C002 . 0x01
comment C002 .-
comment C002 .M00AB - tone duration in ticks
comment C002 .-
comment C002 .M00AD bits set to 0x01 new mode is activated
comment C002 . 0x80
comment C002 . 0x40   
comment C002 . 0x20   
comment C002 . 0x10   
comment C002 . 0x08   
comment C002 . 0x04   
comment C002 . 0x02   
comment C002 . 0x01   
comment C002 .-
comment C002 .M00AE alert tone set by ALRTTN to D1, Data 2, Data 3.  Bits:
comment C002 . 0x80 D1: 1 = continuously repeat pattern
comment C002 . 0x60: Data 2 Priority  00: lowest, 01 low, 10 high, 11 highest
comment C002 . 0x1f: Data 3 frequency in 100 Hz increments 1 = 100 hz... 31 = 3100hz
comment C002 .-
comment C002 .M00AF alert tone set by ALRTTN Data 4 - pattern number
comment C002 .-
comment C002 .M00B0 bits - alert tone state
comment C002 . 0x10 ???
comment C002 . 0x08 ???
comment C002 . 0x04 ???
comment C002 . 0x02 Turned off when ALRTTN sents a new pattern
comment C002 . 0x01 ???
comment C002 .-
comment C002 .M00B5 subroutine address called by main loop under TBD conditions
comment C002 .-
comment C002 .M00B7, M00B9 - value of FRC (Free Running Counter) at next tick
comment C002 .-
comment C002 .M00BE bits
comment C002 . 0x80
comment C002 . 0x40   
comment C002 . 0x20   
comment C002 . 0x10   
comment C002 . 0x08 Tx key up event handled ??
comment C002 . 0x04   
comment C002 . 0x02   
comment C002 . 0x01   
comment C002 .-
comment C002 .M00BF bits
comment C002 . 0x80
comment C002 . 0x40   
comment C002 . 0x20   
comment C002 . 0x10
comment C002 . 0x08
comment C002 . 0x04 - set by PTTINH when PTT is enabled
comment C002 . 0x02 - test mode enabled by jumper   
comment C002 . 0x01
comment C002 .BUSYFLAGS1 bits (0x88)
comment C002 .0x80 - reset not needed when exiting programming mode (set at reset, cleared by MEMACS w/o Bit 0x2 set)
comment C002 .0x20 - programming mode MEMACS received, only MEMADD, MEMFRA, and DEVJSR commands allowed
comment C002 .0x10 - if not set then exiting programming mode causes a reset
comment C002 .0x08 = sending serial data
comment C002 .-
comment C002 .Mode table
comment C002 . Offset 
comment C002 . 0x00 RX synthesizer programming bits
comment C002 . 0x03 TX synthesizer programming bits
comment C002 . 0x06 Index into PL table for Rx/Tx tone/code
comment C002 . 0x07 Tx timeout
comment C002 .   0x80 PTT NOT allowed
comment C002 .   0x7f Tx timeout timer<br>0=None, otherwise timeout in units of 5 seconds
comment C002 . 0x08 Bit mapped
comment C002 .   0x80 ??
comment C002 .   0x40 ??
comment C002 .   0x20 ??
comment C002 .   0x18 Talkback scan 00=Off, 01=not used, 10=On, 11=Operator select
comment C002 .   0x04 0=Carrier squelch, 1=Coded
comment C002 .   0x03 Scanning 0=Off, 01=not used, 10=On, 11=Operator select
comment C002 . 0x09 Bit mapped
comment C002 .   0x80 MPL for Rx tone/code
comment C002 .   0x40 MPL for Tx tone/code
comment C002 .   0x20 ??
comment C002 .   0x10 ??
comment C002 .   0x08 reverse burst enabled
comment C002 .   0x04 ??
comment C002 .   0x03 Mute/unmute type 00=STD/STD, 01=not used, 10=AND/STD, 11=AND/OR |
comment C002 . 0x0a Bit mapped
comment C002 .   0x80 ??
comment C002 .   0x40 ??
comment C002 .   0x20 ??
comment C002 .   0x10 extender on (lowband only)
comment C002 .   0x08 ??
comment C002 .   0x04 DTMF unit - enable mode-slaved DTMF unit call
comment C002 .   0x02 DTMF unit - mode slaved telephone interconnect RX
comment C002 .   0x01 DTMF unit - mode slaved telephone interconnect TX
comment C002 . 0x0b Priority 1 scan mode index
comment C002 . 0x0c Priority 2 scan mode index
comment C002 . 0x0d talk around TX synthesizer programming bits
comment C002 . 0x10 Non priority (NP) scan list bit map
comment C002 .-
lcomment C040       Disable IRQ1/2, Memory Ready, Halt, Auto Memory Ready inputs on Port 5
lcomment C043       Enable on-chip RAM, leave standby
lcomment C046       Initialize stack pointer to top of RAM
lcomment C049       Make port 6 all output & set detector mute
lcomment C051          Make Port 5 b2 an output
lcomment C055          Set i/o directions for RAM / Processor control
lcomment C059          Set i/o directions for clock/timer port
lcomment C05D          Seems to set noDeEmph+noFlat+noSplatter+Preamp/WE+Squelch=11+MicMute
lcomment C05F       Initialize audio control bus
comment C062 .(_Writes_ to C000 are actually i/o, not memory)
lcomment C068          Clear memory from 0x5F to 0x140
lcomment C06E          Clear memory from 0x5F to 0x140
lcomment C070       Frob the watchdog.  It doesn't seem to matter what you write to address 2
comment C073 .of the synthesizer, which is probably why this set of addresses was chosen.
comment C073 .The A3 bit turns into strobe.  Thus we set <something> into A2, then set
comment C073 .it again with strobe, then clear strobe.
lcomment C079       Calculates the simple sum of the entire firmware ROM except for the first
comment C07C .two bytes, i.e. C002-FFFF.  Result is checked by the caller.  It appears
comment C07C .that the loop can run long enough to sum about 1024 bytes before needing
comment C07C .to frob the watchdog.  The manual says the watchdog is supposed to be
comment C07C .reset every 20ms or so, and that if the count hits 30ms, the 'dog resets
comment C07C .the radio.
lcomment C082       Error code 81 is one of the "bad eeprom" codes
lcomment C085       Checksum of code plug rom
lcomment C093       Error code 82 is one of the "bad eeprom" codes
lcomment C096       Frob watchdog
lcomment C0A2          Test RAM from 0x5F to 0x140.  In the process, exercise the ALU a bit.
lcomment C0AB       Error code 88 is "bad cpu"
lcomment C0B5       Error code 88 is "bad cpu"
lcomment C0BE       Frob watchdog
lcomment C0C7          Do additional initialization of processor, and of memory data structures
comment C0C9 .Fetch RAM/Port 5 Control Register
lcomment C0C9          High bit of this port indicates whether standby
comment C0CB .power has been supplied (bit=1), in which case
comment C0CB .this isn't a coldstart.
lcomment C0CE          0x40-41 gets initialized later.  If it's already
comment C0D0 .full of 0xA55A, then coldstart has run before.
lcomment C0D2       0xA0 seems to be the error code storage location
comment C0D5 .All the error codes seem to include the 0x80 bit
lcomment C0D5          So we found a fault during test
lcomment C0D7          Check that the current squelch level is < 5
lcomment C0DD       Observed to contain $20 in 2k, $40 in 8x code plugs
comment C0E0 .Max mode number?
lcomment C0E0       Apparently all of these locations should be > 0 and < ??max mode #??
comment C0E3 .Current mode number of 0 means uninitialized
lcomment C0E5          Current mode number > max mode means uninitialized
lcomment C0E9       ??? of 0 means uninitialized (related to mode numbers)
lcomment C0EE          ??? > max mode number means uninitialized
lcomment C0F2          ??? > max mode number means uninitialized
lcomment C0F6          ??? > max mode number means uninitialized
lcomment C0FA       Initial mode to select in code plug header
lcomment C0FF          This test is weird, seems like $48 would have to contain a mode
comment C101 .number higher that the "initial" for this to be uninitialized.
lcomment C101          We passed all the validity checks
lcomment C103             Radio didn't pass at least some of its "setup is valid" checks, so do full initialization
comment C104 .Clear some fields
lcomment C104          The 0x4_ range seems to be code plug data.
lcomment C10F          Clear 0x4F to 0x5F
lcomment C115          Clear 0x4F to 0x5F
lcomment C11B       Initial mode number to select, from code plug header
lcomment C124       This should be in the code plug header
lcomment C129       get default squelch level from CP
lcomment C12C          save as current squelch level
lcomment C12E       This should be in the code plug header
lcomment C140       Set "standby power was provided" flag
comment C143 .Do we use this as a "loaded mode data is valid" flag?
lcomment C143       Set the "radio was initialized" pattern
lcomment C148       Radio passed all validity checks, so we don't need to do some of the initialization.
comment C14B .-or-
comment C14B .We fell through from the coldstart setups and continue with the warmstart ones.
lcomment C164          get current squelch level
lcomment C170       Calculate memory offset of current mode entry in code plug
comment C173 .Uses $77 as source, $A1 as destination
lcomment C173       Calculate memory offset of current mode entry in code plug
comment C176 .Uses $43 as source, $A3 as destination
lcomment C17A       This should be in the code plug header
lcomment C17F       This should be in the code plug header
lcomment C184       send RADRDY
lcomment C187       This bit doesn't seem to get set until later
comment C18A .So what condition are we testing for here?
lcomment C18C       Ditto the bottom two bits
lcomment C194       Are we in test mode? (jumper installed)
lcomment C199       Maybe stash the status of test mode in $BF?
lcomment C19C       set bits 0x80 and 0x10
lcomment C19F       Frob the watchdog
lcomment C1A8       This should be in the code plug header
lcomment C1AB       Seems to calculate ((b//5)\*6) + (b%5)
lcomment C1B0       This should be in the code plug header
lcomment C1B3       Seems to calculate ((b//5)\*6) + (b%5)
lcomment C1B8       Frob the watchdog
lcomment C1C1       This routine seems to build bitmaps of bytes on even zero and eight offsets
comment C1C4 .from the beginning of the code plug which have bits $80 or $40 set.  256 bytes
comment C1C4 .are scanned, so four bytes are used for each bitmap.
lcomment C1C4          Serial comms setup
comment C1C6 .$05 = 00 0 001 01 so:
comment C1C6 .SS = 001 -> Baud rate = E / 128 = 1.2288 / 128 = 9600
comment C1C6 .CC = 001 => 8 data bits, internal clock, Port 2 bit 2 not used
lcomment C1C8       timer 2 enab, output 1, clock=E/8
comment C1CB .time constant 0x60
comment C1CB .This time constant would seem to work out to
comment C1CB .around 2,560 bps if it's used for the serial bus.
comment C1CB .TCSR3 = 0x1d  0 0 0 1 11 01
comment C1CB .CKS = 01: E clock / 8
comment C1CB .TOS = 11: output 1 on timer compare to port 2 bit 6 (alert tone)
comment C1CB .T2E = 1: timer 2 clock is enable
comment C1CB .ECMI = 0: counter match interrupt disabled
comment C1CB .CMF = 0: r/o status bit
comment C1CD .0x1c is the time constant register
lcomment C1CD       0x11 is tx/rx control status register 1
lcomment C1D0          Receive interrupt enable, receive enable, transmit enable
lcomment C1D4          This reads TRCSR1, then RDR, which clears the
comment C1D6 ."Receive Data Register Full" bit in TRCSR1.
comment C1D6 .We previously set "Busy" on the SB9600 link, and
comment C1D6 .we're throwing away anything we got here, so this
comment C1D6 .should leave the link in a clean state.
lcomment C1D6          Timer setup
comment C1D8 .0x0f is the timer status / control register
lcomment C1D8          0x0d is the input capture register msb
lcomment C1DA       Seems like a pointer?
lcomment C1DF       Enable Output Compare Interrupt 1
lcomment C1E2             Turn on interrupts
lcomment C1E3       Set SB9600 "/BUSY" output on port2 pin2 (cpu pin 10)
comment C1E6 .At startup, this pin should be low, so the bus should
comment C1E6 .be held busy until now.
lcomment C1E6       This should be in the code plug header
comment C1E9 .All available plugs have $13 here
lcomment C1F7          Clears Timer Overflow flag.
lcomment C1F9          Not clear what reading this here would do.
comment C1FB .(Reading the ICR instead would clear the
comment C1FB .Input Capture flag.  So is this a bug?)
lcomment C1FB       Enable the timer overflow interrupt
lcomment C1FE       Frob the watchdog
lcomment C207       Disable serial receive interrupts
lcomment C20D       Re-enable serial receive interrupts
lcomment C216          Disable serial Transmit Data Empty interrupts
lcomment C21D       Disable serial Transmit Data Empty interrupts
lcomment C226       Frob the watchdog
lcomment C241             Disable interrupts
lcomment C242          Hang the radio
lcomment C24C       Disable serial interrupts
lcomment C256             Inhibit interrupts
lcomment C257          Fetch the current value of the Free Running Counter
lcomment C25B             Re-enable interrupts
comment C25C .-------------------- Main forever loop ??!!?? ------------------------------
lcomment C25C          Wait for free running counter to pass zero (about 53ms).
comment C262 .New tick (about once every 2.6ms)
lcomment C264       Reset timeout
lcomment C269          Set all port 2 to all output except pin 0: timer 1 input
lcomment C26D          Port 6 is mostly audio ctl bus
lcomment C26F          set port 6 to all outs
lcomment C271       toggle even/odd loop bit
lcomment C274       Odd loop?
lcomment C277          jump if so
comment C279 .execute once every other loop (4.2ms)
lcomment C279       transmitter keyed?
lcomment C27C          jump if not
comment C27E .Handle Transmitter related stuff
comment C292 .-
lcomment C298       squelch decision ?
comment C2A3 .-
comment C2AA .Handle non transmitter related stuff handled on every other loop
lcomment C2AD          get timer
lcomment C2AF          jump if notrunning
lcomment C2B1       decrement timer
comment C2BC .-
lcomment C2C8       note: the first entry skipped so table really starts at C5DF
lcomment C2D6          call routine via table
comment C2DE .-------------------- End of forever loop ------------------------------------
lcomment C2DE       Disable receive interrupts on serial
lcomment C2E4       Re-enable receive interrupts on serial
lcomment C2E8       Frob the watchdog
comment C2FF .-
lcomment C30D          jump if opcode < $07
lcomment C30F          get address
lcomment C311          mask group
lcomment C313          jump if broadcast
lcomment C315       get our address
lcomment C318          get our group
lcomment C31A          jump if group 0 (no group?)
lcomment C31C             full match for group/device address?
lcomment C31F             not for us, ignore it
comment C320 .command is for us, process it
lcomment C326          ignore unsupported opcode
lcomment C32F          jump to opcode handler
comment C332 .-
lcomment C332       Test "Busy In" (active low)
lcomment C341          It appears the FRC is never _set_.
comment C343 .It is read in various places, often with bits
comment C343 .of math done on it, and comparisons.  I
comment C343 .suspect that means everything is done
comment C343 .relative to a previous read.
lcomment C346       1.042 ms -- one character time at 9600 baud
comment C34E .Loop looking for the first bit set in the 32 bit bitmapped vector
comment C34E .M008D -> M0090
lcomment C34E             So we are busy
lcomment C352          get bit map ??
lcomment C354          Jump if any bit is set
lcomment C356             no bits set, next byte
lcomment C35A          loop 4 times
comment C35D .A = bitmap, B = 0 to 3.  jump to routne based on B\*8 and the first bit set in A
comment C35D .scanning from the MSB
lcomment C35D       Jump table base
lcomment C360             \* 2
lcomment C361             \* 4
lcomment C362             \* 8
lcomment C363             \* 16
comment C365 .search for first bit set in A and then jump to the corresponding routine
lcomment C365             skip entry
lcomment C36A          get routine address
lcomment C36C          jump to it
comment C36E .-
lcomment C372          Remember updated FRC value
lcomment C374          Is this the timer for SB9600 turnaround wait / acks / &c?
comment C37A .-
lcomment C38F          clear rx count
lcomment C394          Serial Communications unit interrupt handler
lcomment C396             Enable interrupts
lcomment C3DF          read byte
lcomment C3E1          save in rx data buffer
lcomment C3F6             crc good?
lcomment C3F7          yes!
comment C3F9 .5 byte command with CRC error received
lcomment C401       Clear /BUSY
comment C417 .-
lcomment C417             Disable interrupts
lcomment C41A       Set SB9600 "/BUSY" output on port2 pin2 (cpu pin 10)
comment C430 .5 byte command with good CRC receved
comment C440 .-
lcomment C446       Set SB9600 "/BUSY" output on port2 pin2 (cpu pin 10)
comment C45F .-
comment C498 .-
lcomment C4A0          send byte
comment C4A3 .-
comment C4B4 .OCF (timer output compare) interrupt handler
lcomment C4C4       Set SB9600 "/BUSY" output on port2 pin2 (cpu pin 10)
lcomment C4C9       Test "Busy In" (active low)
lcomment C4D7          get first byte of packet
lcomment C4D9       start sending packet
lcomment C4F5       Clear /BUSY
lcomment C50C       Set SB9600 "/BUSY" output on port2 pin2 (cpu pin 10)
lcomment C517          jump to routine to set next timeout (saved previously)
comment C51B .-
lcomment C51B       get our address
lcomment C51E             incb
lcomment C51F             incb
lcomment C520          save first byte of packet sa address +2 (MPL???)
lcomment C522          bra-relative
comment C524 .-
lcomment C524       ldab-extend
lcomment C527             incb
lcomment C528          save our address + 1 (DSP ???)
lcomment C52A          bra-relative
comment C52C .-
lcomment C531          start sending packet
lcomment C533       get our address
lcomment C536          save it 
comment C53A .-
lcomment C53B          adr = broadcast
lcomment C53F       Test "Busy In" (active low)
comment C544 .Send byte in ACCB, return with interrupts disabled
lcomment C544       Clear /BUSY
lcomment C555          send byte
lcomment C557             set carry ??
comment C55A .First level opcode handler jump table opcodes 0x00 to 0x3f
comment C55A .opcodes above 0x3f are not supported by the X9000
lcomment C55A This is a branch table referenced via X from 0xC320
comment C56A .0x08
comment C57A .0x10
comment C59A .0x20
comment C5BA .0x30
comment C5DF .-
comment C5ED .32 entry jump table note first entry is skipped 
comment C5F5 .0x03
comment C5FD .0x07
comment C605 .0x0b
comment C60D .0x0f
comment C615 .0x13
comment C61D .0x17
comment C625 .0x1b
comment C62F .end of table
comment C62F .called when 0x04 is set in M0090
comment C633 .-
comment C637 .-
lcomment C65D          PRUPST
lcomment C661       set 0x40 in M0062 sometime later
comment C667 .Yes this really is code!  Executed via jump table @ C6D6
lcomment C6CA          PRUPST
comment C6CF .-
comment C716 .heart beat interrupt (timer overflow)
lcomment C729       set port 6 to all inputs
comment C731 .Shit happens, timeout the watchdog timer
comment C733 .-
comment C747 .-
lcomment C747       
lcomment C74C       Calculates the simple sum of the entire firmware ROM except for the first
comment C74F .two bytes, i.e. C002-FFFF.  Result is checked by the caller.  It appears
comment C74F .that the loop can run long enough to sum about 1024 bytes before needing
comment C74F .to frob the watchdog.  The manual says the watchdog is supposed to be
comment C74F .reset every 20ms or so, and that if the count hits 30ms, the 'dog resets
comment C74F .the radio.
comment C74F .Start of contents to test seems to be C002
lcomment C74F       End address of first block to test
lcomment C75B          ROMCKSUM+2Dj
comment C75D .Resulting sum checked by caller
lcomment C761          Resulting sum checked by caller
lcomment C765       Frob watchdog?
lcomment C770       Next 1024 bytes...
lcomment C779          Resulting sum checked by caller
lcomment C77B             End of function ROMCKSUM
lcomment C77C       Checksum of code plug rom
comment C77F .Observed values for first two bytes of a
comment C77F .code plug are 0x07ff (2047) and 0x1fff
comment C77F .(8191).  First bytes of FFFF seem to mean
comment C77F .a bad ROM (reading "nothing there" would
comment C77F .return FF bytes, right?), and we branch
comment C77F .to code which further refines that diagnosis.
lcomment C77F             Now we should have 0x0800, 0x2000, or 0x0000.
lcomment C780          If we got 0xFFFF, go refine diagnosis
lcomment C783       Now we should have 0x8800 or 0xa000.
lcomment C786             Not clear how this would ever see nonzero.
comment C787 .Guessing this is a way to further check
comment C787 .ROM size -- if low-order byte is not FF
comment C787 .(now incremented, so 0x00) then something
comment C787 .is scrambled?  This means the code works
comment C787 .for ROM sizes other than 2x16 and 2x64.
lcomment C789          All observed inputs would lead to 0 and no branch.
comment C78B .Again, guessing this check against the high-order
comment C78B .byte of the size is done this way to allow
comment C78B .ROMs larger than 2x16 and 2x64.
lcomment C78D          Otherwise, end location is in D and can
comment C78F .be passed to ROMCKSUM.
lcomment C78F       End of first cycle is 0x8200
lcomment C794       Start of first cycle is 0x8004 (i.e. don't
comment C797 .sum the size and expected sum)
lcomment C797          And we re-use the firmware checksum routine
lcomment C799       PLUGCK+Bj ...
comment C79C .Ultimate end will be 0xA000
lcomment C79E       End of the first set will be 0x8100
lcomment C7A3       Start scan at 0x8000
lcomment C7A6          We'll search for non-0xFF
lcomment C7A8          PLUGCK+4Bj
comment C7AA .Find non-FF
lcomment C7AA          Error code 82 is one of the "bad eeprom" codes
lcomment C7AF          Find non-FF
lcomment C7B2       Frob watchdog?
lcomment C7BF       Move goalpost for next set
lcomment C7C7          Find non-FF
lcomment C7C9       At this point, the ROM space is totally blank (all 0xff).
comment C7CC .Error code 84 is one of the "bad eeprom" codes
lcomment C7CD       Error code 82 is one of the "bad eeprom" codes
lcomment C7D0             End of function PLUGCK
lcomment C7D1             This routine seems to build bitmaps of bytes on even zero and eight offsets
comment C7D2 .from the beginning of the code plug which have bits $80 or $40 set.  256 bytes
comment C7D2 .are scanned, so four bytes are used for each bitmap.
lcomment C7DF          Outer loop counter
lcomment C7E3          Memory stride for below?
lcomment C7E5       Start address of code plug
lcomment C7E8          Inner loop counter
lcomment C7EA             We're going to shift a 0 bit in during a later ROL.
lcomment C7EB       First pass, this points to code plug header
comment C7EE .(If $80 bit is set, the plug shouldn't be valid
comment C7EE .according to my current understanding?  $40
comment C7EE .and $20 occur in available code plugs at $08.)
lcomment C7F1       First time, should test $8000
lcomment C7F6             Otherwise, we're going to shift a 1 bit in during a later ROL
lcomment C7F7          We appear to get here if the plug has the $40 bit set in its first byte.
comment C7F9 .This bit isn't set in any of the available factory codeplugs.
lcomment C7F9          First time, should ROL $0066
lcomment C7FE          We appear to get here if the plug has the $80 bit set in its first byte.
comment C800 .The only two known valid values do not have this bit set.
lcomment C800          First iteration, it should ROL $0066
lcomment C803          First time, this should ROL $0062
lcomment C806             Add 8, as set above, so after first ABX it should be $8008
lcomment C807             Count down from 8, as set above
lcomment C80A       Increment pointer
lcomment C80D       Decrement outer loop counter
comment C816 .-
lcomment C81C group 0/dev adr = MPL
lcomment C820       activate the mode
comment C824 .-
comment C82A .-
comment C831 .-
comment C838 .-
lcomment C83F             Seems to calculate ((b//5)\*6) + (b%5)
comment C89F .handle VOLVAL opcode
lcomment C89F       read request?
lcomment C8A2          jump if so
comment C8A4 .set volume
lcomment C8AF          get D1 D2
lcomment C8B3          jump if neither are set
lcomment C8B5             move D1 D2 into bits 3,2
lcomment C8BC          update M007D 
lcomment C8BE          get D1,D2, Data3 as 16 bit value
lcomment C8C0          ??? MSB is 'x' ???
comment C8C7 .-
lcomment C8CA          set volume
comment C8CD .-
comment C8D1 .handle VOLVAL read request
lcomment C8D5          addressed to radio ?
lcomment C8D7          ignore if not
lcomment C8DD       start sending packet
lcomment C8E9          get volume level
lcomment C8ED          VOLVAL
comment C8F2 .handle SQLVAL opcode
comment C918 .opcode_ACTMDW activate a \*\*OPTION\*\* mode
lcomment C918 get group/dev adr, data1
lcomment C91A          mask D1, D2
lcomment C91C          ignore if neither are set
lcomment C931       Calculate memory offset of current mode entry in code plug
comment C934 .Uses $77 as source, $A1 as destination
lcomment C934       send ACTMDU
comment C93E .-
comment C942 .handle RXAUD opcode
comment C968 .handle TXAUD opcode
comment C9BC .handle DISMUT opcode
comment C9C9 .handle PTTINH opcode
lcomment C9C9       PTT disable?
lcomment C9CC          jump if not
lcomment C9CE       set b3
lcomment C9D1       set b1
lcomment C9D5       clear b3
lcomment C9D8       clear b1
comment C9DC .handle RXPLIN opcode (i.e. carrier squelch, monitor button)
comment C9EF .handle REVINH opcode
lcomment CA04       set PTT bit (PTT inactive)
lcomment CA08       clear PTT bit (PTT active)
comment CA2C .handle ALRTTN opcode
lcomment CA2C          get D1, Data 2, Data 3
lcomment CA2E       continuous pattern ?
lcomment CA31          jump if so
lcomment CA33          save alert tone spec
lcomment CA39             pattern 0 (nothing)
lcomment CA3A          jump if not
lcomment CA3D          turn off tone
comment CA40 .-
lcomment CA87       transmitter keyed?
comment CA93 .handle RPTDIR opcode
comment CAB5 .Handle MEMACS (0x08) opcode
lcomment CAB8          bit D1 is not set, enter normal bus activity
lcomment CABA          get address field
lcomment CABC          jump if broadcast
lcomment CABE          address == radio ?
lcomment CAC0          jump if so
lcomment CAC2       our address?
lcomment CAC5          jump if os
lcomment CACB             our address - 1 ???
lcomment CACC          jump if so
comment CAD8 .-
comment CADE .address matched
lcomment CADE       set programming mode flag
lcomment CAE4          jump if modifying RAM or option device 2
comment CAE6 .-
lcomment CAE6       get address of timer update
lcomment CAE9          save
lcomment CAEB       set port 6 to all inputs
lcomment CAF0          set port2.1 and port2.4 to outputs 
lcomment CAF2          Seems to set RXflat+TXsplatter+noPreamp/WE+Squelch=11+MicMute
lcomment CAF7       clear bit 0x10 - reset needed
lcomment CAFA       clear bit 0x80
comment CAFE .resuming normal bus activity
lcomment CAFE       is D8 set?
lcomment CB01          jump if not and do a RESET
lcomment CB03       is bit 0x10 set?
lcomment CB06          jump if not and do a reset
lcomment CB08       clear programming mode bit
lcomment CB0B       set bit 0x80
comment CB0F .do a reset
comment CB15 .handle MEMADD opcode
lcomment CB15       programming mode?
lcomment CB18          ignore if not
lcomment CB1A       B/R set?
lcomment CB1D          jump if read command
comment CB1F .MEMADD write
lcomment CB1F          get address
lcomment CB21          data to write
lcomment CB23          write it!
comment CB26 .MEMADD read
lcomment CB26          get MSB of address
lcomment CB28          save it in reply
lcomment CB2A       start sending packet
lcomment CB2D          get LSB of address
lcomment CB2F          save it in reply
lcomment CB31          get address to read
lcomment CB33          read byte
lcomment CB35          save it
lcomment CB37          memadd opcode
lcomment CB39          save it
comment CB3C .handle TXCTRL opccode
comment CB5C .handle VOLMIN opcode
comment CB6C .handle ETONOF (extender on/off) opcode
lcomment CB6C          get D1, D2
comment CB70 .Either D1 or D2 must be set whenever an option Broadcasts this opcode.
comment CB70 .When both D1 and D2 are cleared, the Extender is updated to the radio
lcomment CB72             move D1, D2 into upper nibble
lcomment CB7D       Extender on?
lcomment CB80          jump if so
lcomment CB82       clear b4
comment CB86 .-
lcomment CB86       set b4
comment CB8A .-
comment CB8F .handle DEVJSR opcode
lcomment CB8F          get address
lcomment CB99          jump if not for us
lcomment CB9B          get address of routine from message
lcomment CB9D          jump to it!
comment CBA0 .-
lcomment CC13       set routine address
comment CC5C .handle ACRXPL opcode
comment CC81 .handle ACTXPL opcode
comment CCC6 .handle OPTSTS opcode
lcomment CCE4       start sending packet
lcomment CCE7          OPTSTS
comment CCEC .used by entries for opcodes SHOBUT, SETBUT, INCBUT, DECBUT, DELBUT and RCLBUT
comment CCEC .in the first level opcode code table
lcomment CCEC          get address
lcomment CCEE          mask device address
lcomment CCF2          jump if not broadcast, radio, dsp, or mpl
lcomment CCF4             \* 2
lcomment CCF5             \* 4
lcomment CCF6             \* 8
lcomment CCF7             b = device address \* 16
lcomment CCFA          button # < 16 ?
lcomment CCFC          ignore button if not
lcomment CCFE          add button number
lcomment CD07          jump to handler for this opcode/button
comment CD09 .-
comment CD0A .handle ENTBUT opcode
comment CD0F .handle EXTBUT opcode
comment CD14 .Second level opcode code handler jump table
comment CD14 .used for SHOBUT, SETBUT, INCBUT, DECBUT, DELBUT and RCLBUT
comment CD14 .indexed by button number (device adr 
comment CD14 .-
comment CD14 .device address == 0 broadcast
comment CD34 .device address == 1 radio
comment CD54 .device address == 2 DSP
comment CD74 .device address == 3 MPL
comment CD94 .device address == 4 Internal radio options (all buttons are ignored)
comment CDB4 .button handler for HUB addressed to broadcast
comment CDC6 .button handler for ignition sense addressed to broadcast
comment CDD8 .button handler for PTT addressed to broadcast
lcomment CDDA          SETBUT ?
lcomment CDDC          ignore if not
lcomment CDDE       assume we are unkeying ?
lcomment CDE1       were we ?
lcomment CDE4          jump if so
lcomment CDE6       set bit 2 LOW, we're keying up
comment CDEA .button handler for front/rear control addressed to broadcast
lcomment CDEA          get DATA2 and opcode
comment CE00 .button handler for MODE sent to RADIO address
lcomment CE00          get DATA2 and opcode
lcomment CE02       in configuration or ??? mode
lcomment CE05          jump if so
lcomment CE0C          get DATA2 and opcode
lcomment CE0E          SETBUT ?
lcomment CE12          INCBUT ?
lcomment CE16          DECBUT ?
lcomment CE1A          EXTBUT ?
lcomment CE1E          SHOBUT ?
comment CE23 .Mode SETBUT or EXTBUT
comment CE2D .-
lcomment CE2D       send DISPLY mode with new mode
comment CE33 .Mode INCBUT
lcomment CE3B          wrap back to mode 1
comment CE3F .Mode DECBUT
comment CE44 .Activate new mode in A
lcomment CE44          save mode number
lcomment CE4D       Calculate memory offset of current mode entry in code plug
lcomment CE5C       send DISPLY mode with new mode
comment CE60 .-
lcomment CE60       wrap from mode 1 to max mode
comment CE65 .-
comment CE6B .button handler for volume sent to RADIO adr
lcomment CE6B          get DATA2 and opcode
comment CE8B .-
comment CEC8 .-
comment CECE .-
comment CED4 .button handler for squelch sent to RADIO Adr
lcomment CED4          get DATA2 and opcode
lcomment CED6          SHOBUT?
lcomment CEDA          SETBUT ?
lcomment CEDE          INCBUT ?
lcomment CEE2          CBUT ?
lcomment CEE6          ENTBUT ?
lcomment CEEA          EXTBUT ?
comment CEEF .handle SETBUT squelch sent to RADIO
lcomment CEEF          TA2 < 5 ?
lcomment CEF1          jump if so and save it
lcomment CEF9          get current squelch level
lcomment CF02          get current squelch level
lcomment CF07          save current squelch level
lcomment CF1B          get current squelch level
comment CF23 .-
comment CF29 .button handler for 0x0104:"repeat/direct"
lcomment CF29          get DATA2 and opcode
lcomment CF32       calculate mode adr in EEPROM
lcomment CF49          get DATA2 and opcode
comment CF6B .button handler for 0x0105:"monitor"
lcomment CF6B          get DATA2 and opcode
comment CF97 .button handler for 0x0106:"extender"
lcomment CF97          get DATA2 and opcode
lcomment CFA0       calculate mode adr in EEPROM
lcomment CFB2          get DATA2 and opcode
comment CFD4 .button handler for 0x0108:"home"
lcomment CFEB       Calculate memory offset of current mode entry in code plug
comment CFEE .Uses $43 as source, $A3 as destination
lcomment CFFA       send DISPLY mode with new mode
comment D001 .button handler for 0x010D:"alarms"
comment D009 .button handler for 0x010F:"alarms select"
lcomment D009          get DATA2 and opcode
comment D078 .button handler for 0x010E:"alarms on/off"
lcomment D078          get DATA2 and opcode
comment D0B5 .button handler for scan on/off sent to DSP
lcomment D0B5          get DATA1 and DATA2
lcomment D0B7 DATA2 == 9?
lcomment D0B9 jump if not
lcomment D0BD scan (on or oper select) ?
lcomment D0C0          return if not
lcomment D0C5          return if not
lcomment D0C7 DATA2 == 10 ?
lcomment D0C9 jump if so
lcomment D0CB DATA2 == 11 ?
lcomment D0CF DATA2 == 12 ?
comment D0D4 .-
comment D0E3 .-
comment D0E7 .button handler for scan mode sent to DSP
lcomment D0E7          get DATA2 and opcode
lcomment D11A       scanning enabled ?
lcomment D11D          jump if not
comment D178 .-
comment D2C3 .button handler for 0x0202:"dynamic scan functions"
lcomment D2FD       transmitter keyed?
lcomment D340       transmitter keyed?
comment D391 .button handler for 0x0203:"talkback scan"
lcomment D391          get DATA2 and opcode
comment D3C3 .button handler for 0x0300:"MPL on/off"
lcomment D3C3          get DATA2 and opcode
lcomment D3CC       calculate mode adr in EEPROM
lcomment D3E1       calculate mode adr in EEPROM
lcomment D3F3          get DATA2 and opcode
comment D421 .button handler for 0x0301:"MPL code"
lcomment D421          get DATA2 and opcode
comment D540 .Called when 0x80 is set in M008D
lcomment D548          return bus is busy
lcomment D54A       clear request bit
lcomment D54D          RADRDY
lcomment D551       set 0x80 in M008D, i.e. RADRDY
comment D578 .Called when 0x40 is set in M008D
lcomment D57B          return bus is busy
lcomment D57D       clear request
lcomment D58A          ACTMDU
comment D594 .-
comment D594 .Called when 0x20 is set in M008D send RXMODE
lcomment D597          return bus is busy
lcomment D599       clear request
lcomment D5A1       calculate mode adr in EEPROM
lcomment D5B1          RXMODE
comment D5BB .Called when 0x10 is set in M008D, send TXMODE
lcomment D5BE          return bus is busy
lcomment D5C6       calculate mode adr in EEPROM
lcomment D5D6          TXMODE
comment D5E0 .Called when 0x08 is set in M008D, send RADKEY
lcomment D5E3          return bus is busy
lcomment D5E5       clear request
lcomment D602          RADKEY
comment D60C .Called when 0x04 is set in M008D, send SQLDET
lcomment D60F          return bus is busy
lcomment D611       clear request
lcomment D61C          SQLDET
comment D626 .Called when 0x02 is set in M008D, send PLDECT
lcomment D629          return bus is busy
lcomment D63E          PLDECT
comment D648 .Called when 0x01 is set in M008D, try to send AUDMUT
lcomment D64B          return bus is busy
lcomment D64D       routine succeeded clear request
lcomment D650             D1: 0 assume audio is not muted
lcomment D656             set D1: audio is muted
lcomment D659          send AUDMUT
comment D663 .Called when 0x80 is set in M008E, send ACTSTU
lcomment D666          return bus is busy
lcomment D668       clear request
lcomment D66F          ACTSTU
comment D679 .Called when 0x40 is set in M008E, send PTTINH
lcomment D67E       clear new mode bit
lcomment D682       PTT disabled ?
lcomment D685          jump if so
lcomment D68A          PTTINH
comment D694 .called with  0x20 is set in M008E send DISPLY mode, new mode number
lcomment D697          return bus is busy
lcomment D69C          field ID = mode
lcomment D6A0          get mode to display
lcomment D6A2          save data2/display data
lcomment D6A4          DISPLY
comment D6AE .called when 0x10 is set in M008E send DISPLY
lcomment D6B1          return bus is busy
lcomment D6B3       clear request
lcomment D6B6          Adr = MDC600 SelCall
lcomment D6BE          DISPLY
comment D6C8 .called when 0x02 is set in M008E, send field ID 9
lcomment D6CB          return bus is busy
lcomment D6D0 field ID
comment D6E7 .-
lcomment D6E9          DISPLY
comment D6F3 .called when 0x01 is set in M008E, send field ID 10
lcomment D6F3       return bus is busy
lcomment D708          DISPLY
comment D712 .called when 0x80 is set in M008F, send field ID 11
lcomment D712       return bus is busy
lcomment D727          DISPLY
comment D731 .called when 0x08 is set in M008E send DISPLY Field ID 2
lcomment D734          return bus is busy
lcomment D739          field ID
lcomment D74C          DISPLY
comment D756 .called when 0x04 is set in M008E, send 
lcomment D759          return bus is busy
lcomment D75E field ID
lcomment D762          get current squelch level
lcomment D766          DISPLY
comment D770 .called when 0x40 is set in M008F
lcomment D773          return bus is busy
lcomment D785          DISPLY
comment D78F .called when 0x20 is set in M008F
lcomment D792          return bus is busy
lcomment D7A4          DISPLY
comment D7AE .called when 0x10 is set in M008F
lcomment D7B1          return bus is busy
lcomment D7C3          DISPLY
comment D7CD .called when 0x04 is set in M008F
lcomment D7D0          jump bus is busy
lcomment D7DE          RXPLIN
comment D7E8 .called when 0x02 is set in M008F
lcomment D7EB          jump bus is busy
lcomment D7FC          DISPLY
comment D806 .called when 0x01 is set in M008F
lcomment D809          jump bus is busy
lcomment D81F          DISPLY
comment D829 .called when 0x80 is set in M0090
lcomment D839          DISPLY
comment D843 .called when 0x40 is set in M0090
lcomment D854          ALARMS
comment D85E .called when 0x20 is set in M0090
lcomment D871          DISPLY
comment D87B .called when 0x10 is set in M0090
lcomment D88F          DISPLY
comment D899 .called when 0x08 is set in M0090
lcomment D8AE          DISPLY
comment D8B8 .called when 0x01 is set in M0090
lcomment D8C8          DISPLY
comment D8D2 .called when 0x02 is set in M0090
lcomment D8E6          DISPLY
comment D8F0 .called when 0x08 is set in M008F
lcomment D900          DISPLY
comment D90A .-
lcomment D91D       ptt active?
lcomment D920          jump if not
comment D945 .-
lcomment D945       continuous pattern ?
lcomment D958          get pattern #
lcomment D95A          jump if tone off
lcomment D976       reset to step 0
lcomment D980       time up?
lcomment D983          jump if not
lcomment D985       next step
comment D995 .-
lcomment D9A3       reset to step 0
lcomment D9B1       next step
lcomment D9CF       reset to step 0
lcomment D9DD       next step
comment D9E5 .-
lcomment D9F3       reset to step 0
lcomment DA01       next step
comment DA07 .-
lcomment DA0A       set TOS1 to 1 (output 1 on timer match)
comment DA11 .-
lcomment DA19       continuous pattern ?
lcomment DA1E       clear pattern #
comment DA22 .Generated alert tone
comment DA22 .A: 0x80 D1: 1 = continuously repeat pattern
comment DA22 .   0x60: Data 2 Priority  00: lowest, 01 low, 10 high, 11 highest
comment DA22 .   0x1f: Data 3 frequency in 100 Hz increments 1 = 100 hz... 31 = 3100hz
comment DA22 .B = pattern #
lcomment DA26          table has 0x17 entries
lcomment DA2A             pattern 0 - nothing
lcomment DA2D          get pointer to pattern
lcomment DA2F          get step #
lcomment DA31             offset to current step
lcomment DA35          get duration from table
lcomment DA39          Tone on?
lcomment DA3B          jump if not
lcomment DA44             toss B from stack
comment DA46 .-
lcomment DA49             toss B from stack
comment DA4B .-
lcomment DA52       set TOS1 to 1 (output 1 on timer match)
comment DA57 .-
lcomment DA57       set TOS1 to 0 (output 0 on timer match)
lcomment DA5A             get pattern number 
lcomment DA5B          pattern < 0x15
lcomment DA5D          jump if not
comment DA64 .special handling for patterns 0x15, 0x16, 0x17
lcomment DA64          get second byte from table
comment DA6C .set CKS1, CKS0 to 01: count E clock / 8
comment DA6C .1.2288 Mhz / 8 = 0.1536 Mhz or 6.51 microseconds per count
comment DA6C .provides delays up to 1.66 milliseconds
comment DA74 .set CKS1, CKS0 to 10: count E clock / 128
comment DA74 .1.2288 Mhz / 128 = 9600 hz or 104.16 microseconds per count
comment DA74 .provides delays up to 26.56 milliseconds
lcomment DA76          set timer 2 clock
lcomment DA78          get time constant from table
lcomment DA7A          start timer
comment DA7D .counter 2 time constants for tone generation
comment DA7D .values 0, 1 and 2 are in 104.16 millisecond increments, the rest are in 
comment DA7D .6.51 microsecond increments
comment DA7D .so a value 0x08 is 0x80 \* 
comment DA7D .0 : 0xff \* 104.16 = 26.5608 milliseconds
comment DA7D .1 : 0x30 \* 104.16 = 5 milliseconds
comment DA7D .2 : 0x18 \* 104.16 = 2.5 milliseconds
comment DA7D .3 : 0xff \* 6.51 = 1660.05
comment DA7D .4 : 0xc0 \* 6.51 = 1249.92
comment DA7D .5 : 0x9a \* 6.51 = 1002.54
comment DA7D .6 : 0x80 \* 6.51 = 833.28
comment DA83 .0x06
comment DA89 .0x0c
comment DA8F .0x012
comment DA95 .0x18
comment DA9B .0x1e
comment DA9D .table of pointers to pattern table entries
comment DA9D .each entry is is one or more steps. A step == 0x0000 indicates end of the pattern
comment DAA5 .0x04
comment DAAD .0x08
comment DAB5 .0x0c
comment DACF .-
comment DACF .Pattern table
comment DACF .first byte:
comment DACF .  0x80 = tone on
comment DACF .  0x7f = tone duration in 20 millisecond increments
comment DACF .second byte: 
comment DACF .-
comment DACF .table entry 0x00
comment DAD1 .table entry 0x01
comment DAD5 .table entry 0x02
comment DADF .table entry 0x03
comment DAED .table entry 0x04
comment DAFF .table entry 0x05
comment DB15 .table entry 0x06
comment DB2F .table entry 0x07
comment DB4D .table entry 0x08
comment DB6F .table entry 0x09
comment DB73 .table entry 0x0a
comment DB7D .table entry 0x0b
comment DB8B .table entry 0x0c
comment DB9D .table entry 0x0d
comment DBB3 .table entry 0x0e
comment DBB7 .table entry 0x0f
comment DBC1 .table entry 0x10
comment DBC5 .table entry 0x11
comment DBC9 .table entry 0x12
comment DBCD .table entry 0x13
comment DBD1 .table entry 0x14 - single 40ms click
comment DBD5 .table entry 0x15 - phone ring
comment DC11 .table entry 0x16 - dynamic regroup tone
comment DC1F .table entry 0x17 - talk permit tone
comment DC2F .called from various places and main loop every 4.2 milliseconds
lcomment DC35       transmitter keyed?
lcomment DC88       transmitter keyed?
lcomment DCAB       mute detector
lcomment DCAE       unmute audio
lcomment DCB1          Seems to set noDeEmph+RXflat+TXsplatter+noPreamp/WE+Squelch=11+MicMute
comment DCB3 .-
lcomment DCB6       mute audio
lcomment DCB9          Seems to set noDeEmph+RXflat+TXsplatter+noPreamp/WE+Squelch=11+MicMute
comment DCBB .-
lcomment DCBE       mute detector
lcomment DCC1       mute audio
lcomment DCC4          Seems to set noDeEmph+RXflat+TXsplatter+noPreamp/WE+Squelch=11+MicMute
lcomment DCE5       mute detector
lcomment DCED       unmute audio
lcomment DCF0          Seems to set noDeEmph+RXflat+TXsplatter+noPreamp/WE+Squelch=11+MicMute
lcomment DCF2       mute audio
lcomment DCF5          Seems to set noDeEmph+RXflat+TXsplatter+noPreamp/WE+Squelch=11+MicMute
lcomment DCFE       unmute audio
comment DD02 .-
lcomment DD02       transmitter keyed?
comment DD2E .-
comment DD87 .Scale volume.  Called with B 0x00 -> 0xff
comment DD87 .return B 0x17 -> 0xff and A = something odd that I don't understand
comment DD8D .A:B = ((B / 8) \* 15) + 0x2e
lcomment DD8D       A:B now 0x2e -> 0x1ff
lcomment DD90             A:B now 0x17 -> 0xff
comment DD92 .WTF???
comment DD92 .B is now 0x17 -> 0xff
comment DD92 .b7 of A = is LSB of ((B / 8) \* 15) + 0x2e and b0->b6 = 0
comment DD92 .Seems like the carry should always be cleared but it's tested later by callers???
comment DD92 .WTF???
comment DD93 .-
comment DDAF .called by main loop every 2.1 milliseconds
lcomment DDB3          transmitter keyed?
lcomment DDB7       send RADKEY
lcomment DDBD       transmitter keyed?
lcomment DDC9       transmitter keyed?
lcomment DDE6       squelch decision ?
lcomment DDE9          jump if open
lcomment DDEB       was it open ?
lcomment DDEE          yup, nothing new
comment DDF5 .-
lcomment DE03       send SQLDET
lcomment DE25       send PLDECT
lcomment DE3D       send SQLDET
lcomment DE59       send AUDMUT
lcomment DE5F       audio muted?
lcomment DE87          jump if bit 0x40 (tx pl or dpl) or 1 are set  ???
lcomment DE95       PTT disabled ?
lcomment DEA1       PTT disabled ?
lcomment DEA4          return if not
lcomment DEA6       clear b4? makes no sense, we tested it above so it's already zero
lcomment DEE7       transmitter keyed?
comment DF7C .-
comment DF9B .-
lcomment DFA7       operator select scanning ?
lcomment DFAA          jump if not
comment DFC4 .-
comment DFFA .-
lcomment DFFC          current mode
lcomment DFFE          jump so
lcomment E002       send TXMODE
lcomment E006       calculate mode adr in EEPROM
lcomment E011          get Tx pl/dpl byte
lcomment E025       calculate mode adr in EEPROM
lcomment E03A       calculate mode adr in EEPROM
lcomment E071       calculate mode adr in EEPROM
lcomment E09D       calculate mode adr in EEPROM
lcomment E0E0       calculate mode adr in EEPROM
lcomment E10B          save volume
lcomment E11E          get current squelch level
lcomment E136       clear PTT bit (PTT active)
comment E13A .-
lcomment E14F       transmitter keyed?
lcomment E15D       transmitter keyed?
lcomment E174       transmitter keyed?
lcomment E193       Calculate memory offset of current mode entry in code plug
comment E196 .Uses $77 as source, $A1 as destination
lcomment E1A7       send ACTMDU
lcomment E1AD          invert PTT input
lcomment E254       send RADKEY
comment E258 .-
lcomment E266       calculate mode adr in EEPROM
lcomment E26E       Turn on 9.4v to transmitter
lcomment E271 Send new values to synth chip
lcomment E27E       calculate mode adr in EEPROM
lcomment E298       Turn on 9.4v to transmitter
lcomment E29B Send new values to synth chip
lcomment E2B7       enable PA
lcomment E2DD       switch off 9.4v to transmitter
comment E2F7 .-
lcomment E2FA       switch off 9.4v to transmitter
lcomment E336 Send new values to synth chip
comment E346 .-
lcomment E349       transmitter keyed?
comment E35C .-
lcomment E35C       transmitter keyed?
comment E36D .Calculate memory offset of current OPTION mode entry in code plug, 
comment E36D .saves it in option_mode_adr
lcomment E36D          
lcomment E370       Fetch mode entry size in bytes
lcomment E374       Offset to beginning of mode entries in code plug
lcomment E379 39
comment E37A .-
lcomment E37A          Calculate memory offset of new mode entry in code plug
lcomment E37D       Fetch mode entry size in bytes
lcomment E381       Offset to beginning of mode entries in code plug
lcomment E386             End of function SETUPMODEADDR43
comment E387 .Send new values to synth chip
lcomment E38D       synth sync ?
lcomment E390 loop if sync isn't set yet
comment E392 .-
lcomment E392 init timeout for waiting for sync
lcomment E395 timeout, do it anyway
lcomment E397       synth sync ?
lcomment E39A loop if sync isn't cleared yet
comment E39C .copy from EEPROM to RAM for later load into synthesizer chip
lcomment E39C          get two bytes of Syn bits
lcomment E39E          invert LSB
lcomment E3A0          save in RAM
lcomment E3A4             get upper nibble
lcomment E3A8 invert bit 0x4
lcomment E3B0       transmitter keyed?
comment E3B9 .-
lcomment E3BB branch never?  timing?
comment E3BD .-
lcomment E3C1          jump if not lowband
comment E3C3 .low band radio
comment E3CE .-
comment E3D4 .B must be 0x08??? (BandBM seems to be 0x14 for all bands except low band)
lcomment E3E7          branch never ... WTF? manual binary patch ?
comment E3EB .-
lcomment E3EB       clear bit 0x04 (output)
lcomment E3EE          set port 5 direction, all inputs except bit 0x04
lcomment E3F2             waste time?? result isn't used
comment E3F5 .Send 3 bytes from RAM to synthesizer chip
lcomment E3F7       write with strobe low (A3)
lcomment E3FA       write again with strobe high
lcomment E3FD       and once more write with strobe low
lcomment E42F          clear bit 4
comment E44D .called by main loop every 4.2 milliseconds
comment E456 .-
lcomment E459          send data to synthesizer & return
comment E45B .-
lcomment E489       calculate mode adr in EEPROM
lcomment E4B5          get rx DPL/MPL value
lcomment E59C       calculate mode adr in EEPROM
lcomment E5D4          get tx DPL/MPL values
comment E7EA .-
comment E7F5 .-
comment EC24 .      
lcomment EC2A       send RXMODE
lcomment EC35 Send new values to synth chip
comment EC44 .Called from the main loop via M00B5
lcomment EC44       Channel activity ?
comment EC4E .also called from main loop via M00B5
lcomment EC5B       send RXMODE
comment EC82 .-
lcomment EC82 Send new values to synth chip
comment EC8F .called from mainloop via M00B5
lcomment EC93       send RXMODE
comment ED33 .Called from the main loop via M00B5
lcomment ED33       Channel activity ?
comment ED4D .Called from the main loop via M00B5
lcomment ED4D       squelch decision ?
lcomment ED6C       send RXMODE
comment EDA5 .Called from the main loop via M00B5
comment EDD7 .Called from the main loop via M00B5
comment EDE8 .Called from the main loop via M00B5
comment EE1B .Called from the main loop via M00B5
comment EE98 .Called from the main loop via M00B5
comment EEEF .Called from the main loop via M00B5
lcomment EF17 Send new values to synth chip
lcomment EF3E       Channel activity ?
lcomment EF4F       Channel activity ?
lcomment EF60       mute detector
lcomment EF6B       squelch decision ?
lcomment EF82       send RXMODE
lcomment EFB3 Send new values to synth chip
lcomment EFD3       Channel activity ?
lcomment EFE4       Channel activity ?
lcomment EFF5       mute detector
lcomment F000       squelch decision ?
lcomment F017       send RXMODE
lcomment F035 Send new values to synth chip
lcomment F064       Channel activity ?
lcomment F081       Channel activity ?
comment F0A1 .X = mode address for mode # in B
comment FFD9 .I can't find any references to these jumps.  My guess guess is that
comment FFD9 .they are here for the DEVJSR opcode for version independence
lcomment FFE8          ?? the 63a03 manual says doesn't show this as a vector ??
lcomment FFEA          63a03 manual says IRQ2
lcomment FFEC          the 63a03 manual says CMI (timer 2 counter match)
lcomment FFEE          the 63a03 manual says Trap
lcomment FFF0          the 63a03 manual says SIO (RDRF+ORFE+TDRE), i.e. UART
lcomment FFF2          the 63a03 manual says TOI (timer overflow)
lcomment FFF4          the 63a03 manual says OCI (timer output compare)
lcomment FFF6          the 63a03 manual says ICI (timer input compare)
lcomment FFFA          30
lcomment FFFC          23
lcomment FFFE          Disable IRQ1/2, Memory Ready, Halt, Auto Memory Ready inputs on Port 5
